<!DOCTYPE html>
<html lang="es-CO">
    <head id="head">
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-109043245-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-109043245-1');
        </script>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ochoscar - conceptos básicos 1</title>
        <link rel="icon" type="image/png" href="../../../resources/img/fav-icon.png">
        <link rel="stylesheet" href="../../../resources/css/home/index.css" />
        <link rel="stylesheet" href="../../../resources/css/sistemas/java/conceptos_basicos1.css" />
        <link rel="stylesheet" href="../../../resources/script/libs/google-code-prettify/prettify.css" />
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
    </head>
    <body>
        <header>
            Páginas Web de Ochoscar - Programación - Java Básico 1
        </header>
        <nav id="navigator-bar"></nav>
        <article id="main-article">
            <link rel="stylesheet" href="../../sistemas/java/conceptos_basicos1.css" />
            <p align="justify"><center><strong><h1>CONCEPTOS BÁSICOS DE JAVA I</h1></strong></center></p>

            <br/>
            <h3>CONTENIDO</h3>
            <a href="#T1">1. Clases</a><br/>
            <a href="#T2">2. Objetos</a><br/>
            <a href="#T3">3. Métodos</a><br/>
            <a href="#T4">4. Modificadores de acceso</a><br/>
            <a href="#T5">5. Comentarios</a><br/>
            <a href="#T6">6. Método main</a><br/>
            <a href="#T7">7. Miembros estáticos</a><br/>
            <a href="#T8">8. Empaquetamiento</a><br/>
            <a href="#T9">9. Constructores, bloques y ámbitos</a><br/>
            <a href="#T10">10. Referencias, wrappers y tipos nativos</a><br/>
            <a href="#T11">11. Identificadores</a><br/>
            <a href="#T12">12. Palabras reservadas</a><br/>
            <a href="#T13">13. Destrucción de objetos</a><br/>
            <br/>

            <p align="justify">Programar en el lenguaje Java requiere la comprensión profunda del desarrollo orientado a objetos y el manejo de referencias, esto último requiere que el desarrollador tenga claro el modelo de memoria del computador y el manejo de referencias. A continuación se recopilan los conceptos más importantes de este lenguaje. Una recomendación antes de comenzar la lectura es estar muy al tanto de la terminología, en la medida que se apropie de los terminos utilizados será más fácil avanzar.</p>

            <strong><h2 id="T1">1. Clases</h2></strong>

            <p align="justify">Las clases son las piezas fundamentales de programación en Java, sin embargo, es posible aprender a programar usando Java y sin adentrarse en los detalles de la programación orientada a objetos, lo anterior sucede por que a su vez las clases son programadas usando Programación Estructurada, en la Figura 1, se muestra la diferencia existente entre las aproximaciones a la programación siendo los lenguajes de bajo nivel aquellos que se encuentran más cerca de la máquina y los de alto nivel aquellos que se encuentran cerca del humano (programador). Las clases entonces están compuestas por solo dos elementos, que también son llamados miembros:</p>
            <ul>
                <li><strong>Atributos:</strong> también llamados propiedades, variables o campos están relacionados con el estado y los datos que se podrán almacenar.</li>
                <li><strong>Métodos:</strong> también llamados operaciones, procedimientos o funciones están relacionados con las acciones que se podrán ejecutar, aquí se encuentra la lógica.</li>
            </ul>
            <p align="justify">Las clases como tal son simplemente plantillas que ayudan a definir características y normalmente están relacionadas con conceptos concretos o abstractos del contexto que se programa, por ejemplo: Casa, Vehículo, Nota Musical</p>

            <center>
                <figure>
                    <figcaption><strong>Figura 1.</strong> Lenguajes de alto y bajo nivel</figcaption>
                    <img src="../../../resources/img/sistemas/java/lenguajes.png" alt="Lenguajes de programación" height="300px">
                </figure>
            </center>

            <p align="justify">En Java una clase se crea típicamente en un archivo, sin embargo, es posible tener varias clases en un mismo archivo, de cualquier manera un archivo solo puede tener la definición de una clase pública (conceptos como público, privado y otros se conocen como modificadores de acceso y se verán más adelante). Es necesario para Java que el nombre de la clase pública coincida con el nombre del archivo. A continuación se muestra un ejemplo de clase:</p>

            <br/>
            <center>
                <strong>Código 1.</strong> Estructura de una clase
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class Person {

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

}</code></pre>
            </center>
            <br/>

            <p align="justify">Esta clase inicia con la palabra reservada <code>public</code> la cual indica que esta clase puede ser usada por otras clases, además tiene un atributo denominado <code>name</code> el cual almacena información del nombre de la persona como una secuencia de caracteres o <code>String</code> y al ser privado este atributo solamente puede ser usado al interior de la clase <code>Person</code>, finalmente tiene dos métodos públicos que permiten acceder al atributo privado, de hecho estos métodos son muy conocidos y se llaman métodos getter and setter y permiten que los objetos de la clase accedan leyendo o escribiendo respectivamente a los atributos privados. Es muy común no permitir el acceso directo de los objetos a los atributos ya que a menudo se quiere implementar una lógica antes de escribir o leer que permita hacer validaciones y transformaciones, por ejemplo si la clase fuera <code>Hora</code> podríamos pensar en almacenarla como la cantidad de milisegundos que han transcurrido desde media noche, en este sentido solamente tendríamos un atributo, pero los métodos set y get podrían establecer y devolver la hora usando un string que la represente. El uso de los métodos getter y setter se conoce como encapsulamiento.</p>

            <strong><h2 id="T2">2. Objetos</h2></strong>

            <p align="justify">Los objetos por su parte son instancias de las clases, es decir, podemos asimilar la clase como un molde y los objetos son aquellas creaciones que salen del molde, por lo tanto cada objeto tiene su propia copia de los atributos y por lo tanto aunque los objetos de una misma clase tengan los mismos atributos podrán diferir en sus valores de forma independiente unos objetos de otros. Crear un objeto también se conoce como instanciar una clase y para ello se usa la palabra reservada <code>new</code> como se muestra a continuación en el listado de código 2.</p>

            <br/>
            <center>
                <strong>Código 2.</strong> Instanciación de un objeto
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">Person p1 = new Person()</code></pre>
            </center>

            <p align="justify">Es importante reconocer la palabra reservada <code>new</code> la cual instancia la clase y crea un nuevo objeto en memoria con su propia copia de las variables o atributos de la clase. El acceso a los miembros del objeto se realiza utilizando el operador punto (.) de esta manera y basados en los modificadores de acceso un objeto puede utilizar sus atributos y métodos.</p>

            <strong><h2 id="T3">3. Métodos</h2></strong>

            <p align="justify">Los métodos y tomando nuestra clase de ejemplo <code>Person</code> son piezas reutilizables de lógica que están programados usando programación estructurada y los cuales en su primera línea (también llamada firma o prototipo) especifican el nivel de acceso, en el ejemplo del código 1 los métodos son públicos, indicando que estos métodos se pueden llamar desde cualquier objeto, continuando con el tipo de retorno, es decir, el tipo de dato que es devuelto a quien lo llame, a continuación un identificador, es decir, un nombre que se le da al método y finalizando con una lista de parámetros separados por coma, opcionalmente los métodos terminan con la especificación de los tipos de errores que pueden lanzar. Para este momento, es importante reconocer el tipo de retorno y los parámetros o en otras palabras, la salida del método y las entradas del método, siendo un caso particular de lo anterior cuando un método no devuelve nada en cuyo caso se utiliza la palabra reservada <code>void</code>, tal como se ha hecho en el método <code>setName</code>. Como nota al margen, se debe considerar que Java es un lenguaje fuertemente tipado, lo que significa que Java verifica que los tipos de datos de las expresiones de retorno o de las expresiones de llamados a métodos que asignan valores a parámetros coincidan, en nuestro ejemplo podemos ver como el tipo de retorno del método <code>getName()</code> es el mismo que la expresión <code>return</code> que en este caso es <code>String</code>.</p>

            <strong><h2 id="T4">4. Modificadores de acceso</h2></strong>

            <p align="justify">Los modificadores de acceso permiten establecer el nivel de visibilidad de una clase, método o atributo en Java, este nivel de visibilidad esta relacionado con los lugares del código donde los podemos referir, esto es lo que se conoce como nivel de exposición a posibles llamadores y por lo general hay que tratar de mantener este nivel de exposición al mínimo posible utilizando lo que conocemos como principio del menor privilegio, es mejor quitar todos los permisos e ir agregando a medida que se necesitan. Java posee cuatro niveles de acceso que son los siguientes:</p>

            <ul>
                <li><strong>Por defecto:</strong> para usar este modificador de acceso no se requiere especificar ninguna palabra clave, solo basta con definir la clase, método o atributo y significa que solamente las propia clase o clases del mismo paquete podrán acceder a dichos miembros</li>
                <li><strong>Privado:</strong> este modificador se utiliza con la palabra reservada <code>private</code>, e indica que los atributos o métodos solamente pueden ser llamados en la propia clase donde se definen</li>
                <li><strong>Protegido:</strong> este modificar se utiliza con la palabra reservada <code>protected</code>, e indica que los atributos o métodos solamente pueden ser llamados en la propia clase donde se definen o en clases derivadas (haciendo uso de herencia)</li>
                <li><strong>Público:</strong> este es el acceso más permisivo de todos y para ello se utiliza la palabra reservada <code>public</code> que indica que cualquier objeto en cualquier clase puede acceder a las clases, métodos o atributos etiquetadas con este modificador de acceso</li>
            </ul>

            <strong><h2 id="T5">5. Comentarios</h2></strong>

            <p align="justify">En todo lenguaje de programación es importante realizar comentarios a fin de permitir documentar el código, de hecho estas es una de las prácticas más convenientes y que todo buen programador tiene en cuenta a la hora de realizar su código, incluso lo hace de forma reflexiva a fin de que la documentación de su código sea de calidad. Java, provee tres tipos de comentario que muestran a continuación.</p>

            <br/>
            <center>
                <strong>Código 3.</strong> Ejemplos de comentarios
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">/*
* Este es un comentario de varias líneas
*/
// Este es un comentario de una línea
/**
* Este es un comentario con propósitos de documentación
*/
</code></pre>
            </center>

            <p align="justify">Los comentarios son código no ejecutable, y es utilizado para clarificar segmentos de código. Los comentarios de documentación utilizan etiquetas especiales para que la utilidad javadoc genere automáticamente archivos HTML que son un compendio de la documentación, estos comentarios se utilizan especialmente con las clases, métodos y atributos. Los comentarios de multiple línea y de una línea no se asocian con la generación de código. Es importante anotar que los comentarios de una línea comentan todo lo que existe a la derecha, por lo que en ocasiones se ponen al final de declaraciones de variables, en general, la practica común utilizada es dejar los comentarios en líneas independientes.</p>

            <strong><h2 id="T6">6. Método main</h2></strong>

            <p align="justify">Cuando se ejecuta un programa quien es encargado de ejecutarlo es un interprete de instrucciones conocido como Java Virtual Machine (JVM), es decir, no es directamente el sistema operativo y el procesador. La JVM busca las instrucciones iniciales a ejecutar en el método especial denominado main. En general, el método main se escribe como se muestra a continuación:</p>

            <br/>
            <center>
                <strong>Código 4.</strong> Declaración del método main
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public static void main(String args[]) {

}
</code></pre>
            </center>

            <p align="justify">La declaración de este método tiene algunas partes importantes a considerar (1) Debe ser publico debido a que el método será invocado por la JVM y por lo tanto debe ser visible desde afuera de la clase donde fue declarado (2) debe ser estático a fin que pueda ser invocado sin necesidad de instanciar la clase (crear un objeto) donde se encuentre (3) no retorna nada debido a que la JVM no espera ninguna respuesta y (4) recibe una lista de parámetros en cadenas de texto o <code>String</code> que son los parámetros de la línea de comandos cuando se ejecuta desde una consola, esta lista de parámetros es un arreglo nativo que puede ser escrito alternativamente como <code>String [] args</code> o también <code>String... args</code> este último caso se conoce como parámetros variables y simplifica las labores de creación de un arreglo al momento de invocar un método que recibe varios parámetros del mismo tipo. Si se quiere ejecutar un archivo .class (el resultante de compilar el archivo .java) el mismo deberá tener al menos un método main, para tal efecto se pueden usar los comandos <code>javac Clase.class</code> y <code>java Clase arg1 arg2</code> respectivamente para compilar y ejecutar desde la línea de comandos.</p>

            <strong><h2 id="T7">7. Miembros estáticos</h2></strong>

            <p align="justify">Los miembros estáticos utilizan la palabra reservada <code>static</code> y permiten vincular un atributo o método con la clase directamente, en este punto es conveniente notar que los atributos son independientes entre los objetos, de tal manera que cada objeto tiene su propia copia de los atributos, sin embargo con los atributos estáticos no ocurre lo mismo ya que solamente existe una copia de los mismos para todas las instancias de una clase (objetos). Con los métodos pasa algo similar, de por si los métodos tienen una sola copia ya que todos los objetos acceden a las mismas instrucciones, sin embargo las variables que utilizan si son independientes por objeto, con un método estático se limita el acceso de dicho método solo a atributos estáticos, esta regla impide por ejemplo que un método estático acceda a un miembro no estático. Al estar asociado los miembros estáticos a la clase los mismos pueden acceder a través del operador punto (.) y utilizando el nombre de la clase, alternativamente puede usarse en objetos. A fin de ejemplificar el uso de métodos y atributos estáticos consideremos el siguiente código</p>

            <br/>
            <center>
                <strong>Código 5.</strong> Miembros estáticos i
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class DemoStatic {

    public int i;

    public static void staticMethod() {
        i = 2;
    }

}
</code></pre>
            </center>

            <p align="justify">Aquí el acceso a la variable <code>i</code> no esta permitido dentro del método estático y la razón es simple: el atributo no es estático, piense en ello un momento ya que lo anterior implica que se pueda hacer un llamado a <code>staticMethod</code> desde la clase, algo como: <code>DemoStatic.staticMethod()</code>, pero al intentar acceder a la variable <code>i</code> ¿cuál valor de variable se debe usar? sabiendo que el llamado se hizo desde la propia clase, por lo anterior no esta permitido acceder a miembros no estáticos desde métodos estáticos. Lo anterior ocurre con frecuencia cuando se comienza a programar en situaciones como la siguiente:</p>

            <br/>
            <center>
                <strong>Código 6.</strong> Miembros estáticos ii
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class DemoStatic {

    public int i;

    public static void main(String args[]) {
        i = 2;
    }

}
</code></pre>
            </center>

            <p align="justify">En esencia es el mismo código anterior, excepto que se esta haciendo uso del método main, para subsanar lo anterior hay dos alternativas (1) convertir la i en atributo estático o instanciar un nuevo objeto de la clase, ambas soluciones se muestran a continuación.</p>

            <br/>
            <center>
                <strong>Código 7.</strong> Miembros estáticos iii
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class DemoStatic {

    public static int i;

    public static void main(String args[]) {
        i = 2;
    }

}
</code></pre>
            </center>

            <br/>
            <center>
                <strong>Código 8.</strong> Instanciación de un objeto estático
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class DemoStatic {

    public int i;

    public static void main(String args[]) {
        DemoStatic ds = new DemoStatic();
        ds.i = 2;
    }

}
</code></pre>
            </center>

            <strong><h2 id="T8">8. Empaquetamiento</h2></strong>

            <p align="justify">Las clases realmente conforman activos de las organizaciones y de hecho muchas de ellas proveen valiosos mecanismos para reutilizar código, sin embargo, miles de clases se producen y debe existir una forma para organizarlas, dicha forma se conoce como empaquetado y el mismo funciona de manera jerárquica. Los paquetes entonces no son más que contenedores de clases y permiten a los programadores agruparlas de forma lógica. Respecto a los paquetes hay dos cosas que quizás no son muy conocidas pero es importante tenerlas en cuenta a la hora de programar, la primera trata del hecho que en todo programa siempre se encuentra importado por defecto el paquete <code>java.lang</code> en este paquete se encuentran las utilidades y clases básicas del propio core de java, por ejemplo, clases para el manejo de número o cadenas de texto y la segunda es que al estar las clases contenidas en paquetes se crea un nombre de clase que incluye la jerarquía de paquetes donde se encuentra, por ejemplo, la clase <code>ArrayList</code> se encuentra en <code>java.util.ArrayList</code>, a este último se le conoce como nombre completamente cualificado. Note que los nombres de los paquetes se separan por punto y que estos nombres al ser jerárquicos se suelen nombrar como nombres de dominio al revés, por ejemplo el paquete <code>com.ochoscar</code><br>También es importante indicar en nuestros archivos y programas que clases utilizamos, esto haciendo uso de la palabra reservada <code>import</code><br>Cuando realizamos importaciones es conveniente tener presente que no hayan validaciones redundantes de clases que teniendo el mismo nombre se encuentren en paquetes diferentes, por ejemplo, la clase <code>Date</code> que se encuentra tanto en el paquete <code>java.util</code> como en el paquete <code>java.sql</code>. Considere el siguiente código:</p>

            <br/>
            <center>
                <strong>Código 9.</strong> Importaciones i
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">import java.util.Date;
import java.sql.Date;

public class DemoImport {

    public static void main(String args[]) {
        Date date;
    }

}
</code></pre>
            </center>

            <p align="justify">Aquí la importación falla al tener la misma clase desde paquetes diferentes, pero ¿qué hacer si se quisiera instanciar un objeto del paquete <code>java.util</code> y a la vez del paquete <code>java.sql</code>? La mejor opción aquí es utilizar los nombres completamente cualificados como se muestra a continuación:</p>

            <br/>
            <center>
                <strong>Código 10.</strong> Importaciones ii
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">import java.util.Date;

public class DemoImport {

    public static void main(String args[]) {
        java.sql.Date date;
    }

}
</code></pre>
            </center>

            <p align="justify">Finalmente, respecto a las importaciones hay dos temas importante, el primero se conoce como wildcard (<code>*</code>) y no es otra cosa que un comodín para importar todas las clases de un paquete, debemos tener cuidado por que el wildcard no incluye subpaquetes, un ejemplo de uso del wildcard sería <code>import java.util.*;</code>, a manera de nota es recomendable notar que los wildcard a su vez pueden producir conflictos de importación y el segundo punto a tener en cuenta son las importaciones estáticas que sirven para importar en el archivo los miembros estáticos definidas en otra clase, esto ahorra el hecho de referirnos a estos miembros usando el nombre de la clase, para referencia observe el siguiente ejemplo: </p>

            <br/>
            <center>
                <strong>Código 11.</strong> Importaciones iii
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">import static java.lang.Math.*;

public class DemoImportStatic {

    public static void main(String args[]) {
        double r = 2;
        double a = PI * r * r;
    }

}
</code></pre>
            </center>

            <p align="justify">En este punto se han visto los componentes esenciales de los archivos de Java, tenga en cuenta que estos componentes deben estar en un orden adecuado para que puedan ser compilados por Java, este orden comienza con las declaración del paquete, las importaciones, la definición de la clase y su contenido, este último normalmente se escribe primero los atributos y luego los métodos, teniendo siempre presente la correcta tabulación, los comentarios de documentación y los nombres adecuados para los identificadores.</p>

            <strong><h2 id="T9">9. Constructores, bloques y ámbitos</h2></strong>

            <p align="justify">Los constructores son métodos especiales diseñados para inicializar los atributos y que se caracterizan por tener el mismo nombre de la clase y adicionalmente por no retornar nada. En el código:</p>

            <br/>
            <center>
                <strong>Código 12.</strong> Constructores
            <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">Random r = new Random();
</code></pre>
            </center>

            <p align="justify">La variable <code>r</code> se encarga de referenciar en memoria a un objeto recién creado de la clase <code>Ramdom</code>. Este objeto ha sido creado invocando el método constructor de dicha clase. Existen tres tipos de constructores tradicionales que son: (1) los constructores por defecto, aquel que no recibe ningún parámetro y que Java incluye automáticamente en caso que el programador no especifique de forma explicita un constructor para la clase, este constructor automático de hecho no ejecuta ninguna instrucción (2) constructor con parámetros, que recibe parámetros referentes a los atributos y normalmente los asigna a los mismos y (3) constructor de copia, que recibe un objeto de la misma clase y realiza una copia de los atributos del parámetro en el nuevo objeto creado. Estos constructores pueden convivir entre sí sin ningún inconveniente siempre y cuando se respeten las reglas de sobrecarga de métodos, dicho de paso un constructor es un método más y las reglas de sobrecarga establecen que los métodos pueden tener el mismo nombre y tipo de retorno siempre y cuando las firmas de los métodos difieran bien sea en tipos de datos de los parámetros o cantidad de parámetros u orden de los mismos o excepciones que arroje el método<br>Ya que un constructor inicializa los atributos del objeto es conveniente entender como se pueden inicializar estos atributos además de la lógica en el constructor y para ello existen tres forma de inicializar: </p>

            <ul>
                <li>Inicialización en línea: ocurre cuando en la misma línea de la declaración se inicializa el atributo, esta es la primera inicialización que tiene un atributo</li>
                <li>Inicialización en constructor: ocurre cuando se agrega lógica al constructor que inicializa la variable, esta es la última inicialización de un atributo</li>
                <li>Inicialización de instancia: ocurre en un bloque de inicialización, estas inicializaciones junto con las inicializaciones en línea se ejecutan en el orden que se encuentren en el código</li>
            </ul>

            <p align="justify">Es importante tener en cuenta que no es posible referirse a una variable que no ha sido inicializada. El siguiente código muestra cada uno de estos esquemas de inicialización:</p>

            <br/>
            <center>
                <strong>Código 13.</strong> Inicializaciones
                <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public class InitExamples {

    public InitExamples() {
        // Inicialización en constructor
        i = 5;
    }

    public static void main(String[] args) {
        InitExamples ie = new InitExamples();
        System.out.println(ie.i);
    }

    // Inicialización en línea
    private int i = 3;

    // Bloque de inicialización de instancia
    { i = 4; }

}
</code></pre>
            </center>

            <p align="justify">¿Qué valor cree que se imprime? Si respondió 5 esta en lo correcto. Adicional observe el bloque de inicialización el cual no tiene etiquetas ni firmas de prototipos o similares, en este bloque se puede incluir la lógica necesaria para inicializar la variable. Respecto a los bloques de código es importante que el programador reconozca que los bloques son trozos de código encerrados entre llaves y que el ámbito (scope en inglés) se refiere a los bloques de código donde se puede referir alguna variable, así:</p>

            <ul>
                <li>Variables locales: son aquellas declaradas dentro de los métodos y se pueden utilizar en el bloque fueron declaradas y en todo caso no antes de su declaración</li>
                <li>Variables de instancia: estas también son conocidas como atributos y se pueden usar en el bloque de su declaración o desde su objeto siempre y cuando cumpla con las reglas de los modificadores de acceso. Es importante recordar que una variable de instancia solo se encuentra en memoria mientras que el objeto al cual pertenece también se encuentre en memoria, por lo tanto cuando un objeto se queda sin referencias es liberado de la memoria mediante el recolector de basura y por hay derecho también es liberada la memoria asociada a las variables de instancia.</li>
                <li>Variables de clase: estas variables son las conocidas como atributos estáticos y esta disponible en el bloque de su declaración y desde los objetos y clases siempre y cuando cumpla con las reglas de los modificadores de acceso. Una variable de clase esta disponible hasta que el programa termina.</li>
            </ul>

            <p align="justify">Las variables de clase o de instancia pueden no ser inicializadas y aun así utilizarse, Java inicializa las variables según el tipo con los siguientes valores por defecto:</p>

            <center>
                <table id="tableVariableInitialValues">
                    <tr>
                        <th><center>Tipo de variable</center></th>
                        <th><center>Valor inicial</center></th>
                    </tr>
                    <tr>
                        <td>boolean</td>
                        <td>false</td>
                    </tr>
                    <tr>
                        <td>byte, short, int, long</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>float, double</td>
                        <td>0.0</td>
                    </tr>
                    <tr>
                        <td>char</td>
                        <td>'\0000' (NUL)</td>
                    </tr>
                    <tr>
                        <td>Referencias</td>
                        <td>null</td>
                    </tr>
                </table>
            </center>

            <p align="justify">Finalmente, y con respecto al tema de inicializaciones y bloques es importante para el programador tener en cuenta que los bloques de inicialización pueden ser marcados con la palabra reservada <code>static</code> de la siguiente manera <code>static { }</code>, este código se ejecutará cuando se cargue la clase y sirve para inicializar atributos estáticos, de manera que en un bloque de inicialización estático solo pueden referenciar en miembros estáticos, similar a como sucede con los método estáticos.</p>

            <strong><h2 id="T10">10. Referencias, wrappers y tipos nativos</h2></strong>

            <p align="justify">Aunque Java puede tener muchas clases, que en general se conocen en el mundo de la programación como tipos de datos definidos por el usuario, en realidad Java solo tiene dos tipos de datos: tipos nativos y referencias. Los tipos nativos son aquellos que almacenan el valor en la misma posición de memoria a la cual se refieren, mientras que las referencias almacenan la dirección de memoria donde reside el objeto. Para facilitar la comprensión de este concepto vamos a comenzar con los tipos de datos nativos los cuales se pueden ver en la siguiente tabla junto con la cantidad de memoria que ocupan y el rango de valores que admiten, note que un tipo nativo no permiten que se les asigne el valor <code>null</code></p>

            <center>
                <table id="tableNativeTypes">
                    <tr>
                        <th><center>Tipo de dato</center></th>
                        <th><center>Tamaño</center></th>
                    </tr>
                    <tr>
                        <td>boolean</td>
                        <td>8 bit (false, true)</td>
                    </tr>
                    <tr>
                        <td>byte</td>
                        <td>8 bit (-128 a 127)</td>
                    </tr>
                    <tr>
                        <td>short</td>
                        <td>16 bit (-2^15 a 2^15-1)</td>
                    </tr>
                    <tr>
                        <td>int</td>
                        <td>32 bit (-2^31 a 2^31-1)</td>
                    </tr>
                    <tr>
                        <td>long</td>
                        <td>64 bit (-2^63 a 2^63-1)</td>
                    </tr>
                    <tr>
                        <td>float</td>
                        <td>32 bit (±3.4x10^-38 a ± 3.4x10^38)</td>
                    </tr>
                    <tr>
                        <td>double</td>
                        <td>64 bit (±1.8x10^-308 a ± 1.8x10^308)</td>
                    </tr>
                    <tr>
                        <td>char</td>
                        <td>16 bit (Valores Unicode)</td>
                    </tr>
                </table>
            </center>

            <p align="justify">En el caso de las referencias, el tamaño que ocupa depende de la arquitectura de la JVM si es de 32 bit o de 64 bit. Los tipos nativos se caracterizan a su vez ser palabras reservadas, es importante comprender que estos tipos nativos no representan clases u objetos y que Java a incluido versiones objetuales de los tipos nativos, así por ejemplo existe <code>Double</code> e <code>Integer</code>. Las constantes numéricas que aparecen en el código son tratadas con <code>int</code> si estas no tienen un punto, en caso que lo tengan son tratadas como constantes numéricas de tipo <code>Double</code>, así mismo se puede forzar a interpretar una constante entera como <code>long</code> si la constante tiene el sufijo <code>L</code> o <code>l</code> (se aconseja utilizar el primero ya que el segundo se asemeja mucho a un carácter 1, en el caso de lsa constantes numéricas de punto flotante se puede forzar a interpretarlas como <code>float</code> si se utiliza como sufijo la letra <code>F</code> o <code>f</code> y finalmente el sufijo para <code>double</code> es d o D, note que todos estos sufijos hacen referencia a tipos nativos y no a los Wrapper correspondientes. Para el caso del tipo de dato <code>char</code> es importante reconocer que los caracteres individuales se encierran entre comillas dobles mientas que las cadenas de caracteres se encierran en comillas dobles.</p>
            <p align="justify">En cuanto a las constantes numéricas, es decir, valores fijos numéricos que aparecen el código se denominan literales (también aplica para valores de texto) y Java automáticamente los trata como <code>int</code> si los mismos no tienen punto decimal, en caso que tengan punto decimal se tratan como <code>double</code>, así mismo los literales pueden usar el carácter <code>_</code> como separador, el prefijo <code>0</code> para indicar base octal, el predijo <code>0x</code> o <code>0X</code> para base hexadecimal y el prefijo <code>0b</code> o <code>0B</code> para base binaria. Algunos ejemplos de literales se muestran a continuación.</p>

            <br/>
            <center>
                <strong>Código 14.</strong> Separadores numéricos
                <pre class="prettyprint linenums" style="width: 800px; text-align: left"><code class="language-java">long max = 1234567890123; // No permitido, el valor literal supera el tamaño del int
double d1 = _1000.00; // El separador no es permitido al principio
double d2 = 1000.00_; // El separador no es permitido al final
double d3 = 1000_.00; //El separador no es permitido al lado del punto decimal
double d4 = 1_00_0.0_0; // Válido
</code></pre>
            </center>

            <p align="justify">Cuando consideramos la creación de un objeto es necesario comprender que realmente se crean dos espacios de memoria diferentes, uno para la referencia y otro para el objeto, note aquí que el objeto a su vez puede estar constituido por tipos nativos u otras referencias, de esta forma el espacio de memoria correspondiente al objeto puede ser referenciado por muchos otras referencias, de hecho, cuando un objeto se queda sin referencias es habilitado para que el recolector de basura libere la memoria asociada a dicho objeto automáticamente, y lo anterior tiene sentido porque si un objeto se queda sin referencias no es posible acceder desde ningún punto del código, el gráfico a continuación ilustra la relación entre referencia y objeto para el siguiente código <code>Person p1 = new Person()</code></p>

            <center>
                <figure>
                    <figcaption><strong>Figura 2.</strong> Relación objetos y referencias</figcaption>
                    <img src="../../../resources/img/sistemas/java/objvsref.png" alt="Objetos y referencias" height="180px">
                </figure>
            </center>

            <p align="justify">Algo importante para notar es que una referencia se crea cuando se declara en cambio el objeto se crea cuando se usa el operador <code>new</code>, por lo tanto se debe comprender que la referencia almacena la dirección de memoria de donde se encuentra el objeto, realmente en Java todas las variables son referencias, es decir, almacenan direcciones de memoria, excepto para los tipos nativos. Lo anterior nos lleva a explorar lo que sucede cuando pasamos parámetros a métodos ya que existen dos formas (1) paso por valor que aplica para atributos nativos y (2) paso por referencia, que aplica para los objetos, a fin de explorar este concepto consideremos el siguiente código.</p>

            <br/>
            <center>
                <strong>Código 15.</strong> Paso de referencias a métodos
            <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public static void main(String... args) {
    int a1 = 1;
    m1(a1);
    System.out.println("a: " + a1);

    Integer i = new Integer(5);
    m2(i);
    System.out.println("Integer i: " + i);

    String s = "hi";
    m3(s);
    System.out.println("s: " + s);

    StringBuffer sb = new StringBuffer("abc");
    m4(sb);
    System.out.println("sb: " + sb);
}

public static void m1(int a) {
    a = a + 1;
}

public static void m2(Integer i) {
    i = i + 1;
}

public static void m3(String s) {
    s = s + "1";
}

public static void m4(StringBuffer s) {
    s.append("d");
}
</code></pre>
            </center>

            <p align="justify">La pregunta es ¿qué se imprime? Lo ideal es revisar con calma antes de contestar. Ahora vamos con cada impresión a revisar el fondo.</p>
            <ul>
                <li>Primera impresión: la primera impresión trata la pregunta si el método <code>m1</code>, es decir, si este método afecta la variable externa, la respuesta es no, debido a que la variable <code>a</code> se pasa por valor al ser de un tipo nativo, termina sucediendo que la variable a del <code>main</code> contiene un valor independiente de la variable <code>a</code> del método <code>m1</code>, por tanto la modificación de la variable <code>a</code> no afecta la variable externa, de hecho el parametro del método <code>m1</code> podría incluso tener otro nombre.</li>
                <li>Segunda impresión: este segundo caso tiene un poco más de truco. Si nos basamos en la teoria aprendida pensaríamos que si se modifica puesto que la variable no hace referencia a un tipo nativo sino a un wrapper, sin embargo en el momento dela suma, la variable <code>i</code> debe ser convertida de <code>Integer</code> a <code>int</code> para poder realizar la suma. Esta característica de Java se llama autoboxing y le permite al lenguaje escribir expresiones con tipos nativos o wrappers de forma equivalente para el programador.</li>
                <li>Tercera impresión: esta impresión también tiene un pequeño truco, puesto que al igual que el caso anterior pensaríamos que se ve afectada la variable externa, sin embargo, esto no sucede ya que <code>String</code> es una clase con comportamientos muy diferentes al resto de clases de Java. Los <code>String</code> en Java son inmutables y se almacenan en una parte especial de la memoria, es decir, una vez definido un <code>String</code> este no cambiará jamás, por lo tanto el append que se observa en el método <code>m3</code> no modifica el <code>String</code> y por esta razón el valor externo no cambia.</li>
                <li>Cuarta impresión: esta impresión asociada al método <code>m4</code> es el único que en realidad es un paso por referencia de manera que lo que hagamos dentro de este método afectará la variable externa ya que ambas variables <code>sb</code> y <code>s</code> referencia el mismo espacio de memoria, esto también se puede notar ya que solamente existe un new, es decir un objeto tipo <code>StringBuffer</code> en este código.</li>
            </ul>

            <p align="justify">Como particularidad de los <code>String</code> cabe anotar que los objetos de esta clase se pueden representar directamente en el código, por ejemplo <code>"hola".length()</code> note que en este caso no fue necesario hacer un nuevo objeto tipo <code>String</code> para invocar el método <code>length()</code>.</p>

            <p align="justify">A fin de tener presente los puntos más importantes acerca del manejo de referencias, el programador de Java debe recordar que las referencias de tipos Wrappers y de tipo <code>String</code> tienen un manejo diferente al resto de referencias, las primeras por que les aplica el concepto de autoboxing y las segundas por que las cadenas de texto son almacenadas de forma inmutable, es decir, una vez definido un <code>String</code> este no puede cambiar durante la ejecución del programa, para ejemplificar este último concepto de la inmutabilidad de los <code>String</code> considere el siguiente código:</p>

            <br/>
            <center>
                <strong>Código 16.</strong> Comparaciones de strings
            <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public static void main(String... args) {
    String str1 = "hola";
    String str2 = "hola";
    String str3 = "hola".trim();
    String str4 = "hola   ".trim();
    System.out.println(str1 == str2);
    System.out.println(str1 == str3);
    System.out.println(str1 == str4);
}
</code></pre>
            </center>

            <p align="justify">Uno pensaría que la primera impresión es <code>true</code> debido a que son referencias diferentes, pero dado que Java almacena los <code>String</code> de forma especial y en una zona especial de la memoria, la asignación de <code>str1</code> y <code>str2</code> terminan apuntando a la misma dirección de memoria. La segunda impresión sigue siendo verdadero debido a que la función <code>trim()</code> que recorta los espacios en blanco al principio y final de una cadena, no realiza en realidad ninguna operación, debido a que no hay nada que recortar, pero algo curioso sucede con la tercera impresión y en este caso arroja <code>false</code> indicando que la referencia <code>str4</code> termina apuntando a un lugar diferente de memoria, y por lo tanto terminan existiendo en memoria dos objetos <code>String</code> con la misma información <code>hola</code>, note que esto sucede porque <code>trim()</code> no puede modificar el objeto original y cuando lo modifica deja el resultado en una posición de memoria nueva y para ello no determina si ese objeto <code>String</code> ya existid. Note que debido a estas características de Java, un programa puede proliferar rápidamente la cantidad de <code>String</code> que tiene creados. Una nota final de los <code>String</code> y esto solamente le sucede a esta clase, y es que no requiere un <code>new</code>, no en el código anterior que se realizaron asignaciones sin necesidad de crear un objeto nuevo y esto es porque Java es capaz de tratar como objetos a las cadenas de texto directamente sobre el código, por lo mismo códigos como el siguiente funcionan correctamente: <code>"hola".trim()</code>. Respecto a la primera impresión del código anterior, que sucedería si en lugar de ser <code>String</code> fueran <code>Integer</code>? y para ello considere el siguiente código:</p>

            <br/>
            <center>
                <strong>Código 17.</strong> Comparaciones de números
            <pre class="prettyprint linenums" style="width: 600px; text-align: left"><code class="language-java">public static void main(String... args) {
    Integer i1 = 10;
    Integer i2 = 10;
    Integer i3 = new Integer(10);
    Integer i4 = new Integer(10);
    System.out.println(i1 == i2);
    System.out.println(i3 == i4);
}
</code></pre>
            </center>

            <p align="justify">Este código realmente puede ser muy desconcertante, que imprimirá? La respuesta es que la primera impresión es <code>true</code> y la segunda es <code>false</code>, la respuesta es la forma en que se crearon los objetos, el primero se hizo usando la característica de autoboxing (recuerde que esta es la habilidad que tiene Java automáticamente de pasar del tipo nativo al Wrapper según se necesite), por lo tanto en la primera ocasión los objetos apuntan a la misma dirección, este caso funciona de forma similar a los <code>String</code> mientras que en la segunda forma los <code>Integer</code> son creados como objetos primero (lo cual hace que ambas referencias <code>i3</code> e <code>i4</code> apunten a direcciones diferentes) y luego se inicializan los valores de estas referencias respectivamente.</p>

            <strong><h2 id="T11">11. Identificadores</h2></strong>

            <p align="justify">Los identificadores son nombres que se ponen a los diferentes elementos del código, son elegidos por el programador y normalmente siguen un estándar, el más usado en Java es camel case, que consiste en crear los nombres en minúsculas excepto por la primera letra de cada palabra, lo anterior ayuda a la legibilidad y evita el uso de guiones bajos. Es importante considerar que los nombre asignados deben ser reflexionados y puestos con calma, ya que los nombres bien escogidos ayudan al mantenimiento y entendimiento del código. Para el caso de paquetes, métodos, atributos, variables se inicia con minúsculas, mientras que las clases y las interfaces comienzan con mayúscula. Todos los identificadores siguen las siguientes reglas:</p>

            <ul>
                <li>El nombre debe empezar con letra o símbolo $ o _</li>
                <li>Caracteres subsecuentes pueden ser números</li>
                <li>No pueden ser palabras reservadas</li>
            </ul>

            <strong><h2 id="T12">12. Palabras reservadas</h2></strong>

            <p align="justify">Las palabras reservadas se utilizan para fines particulares del lenguaje y no pueden ser elegidas o cambiadas a justo del programados. Así mismo, las palabras clave no pueden ser usadas por el programador como identificadores, a continuación se muestra una tabla con las diferentes palabras clave.</p>

            <center><code>
                <table id="tableReservedWords">
                    <tr>
                        <td>abstract</td>
                        <td>assert</td>
                        <td>boolean</td>
                        <td>break</td>
                        <td>byte</td>
                    </tr>
                    <tr>
                        <td>case</td>
                        <td>catch</td>
                        <td>char</td>
                        <td>class</td>
                        <td>const</td>
                    </tr>
                    <tr>
                        <td>continue</td>
                        <td>default</td>
                        <td>do</td>
                        <td>double</td>
                        <td>else</td>
                    </tr>
                    <tr>
                        <td>eunum</td>
                        <td>extend</td>
                        <td>false</td>
                        <td>final</td>
                        <td>finally</td>
                    </tr>
                    <tr>
                        <td>float</td>
                        <td>for</td>
                        <td>goto</td>
                        <td>if</td>
                        <td>implements</td>
                    </tr>
                    <tr>
                        <td>import</td>
                        <td>instanceof</td>
                        <td>int</td>
                        <td>interface</td>
                        <td>long</td>
                    </tr>
                    <tr>
                        <td>native</td>
                        <td>new</td>
                        <td>null</td>
                        <td>package</td>
                        <td>private</td>
                    </tr>
                    <tr>
                        <td>protected</td>
                        <td>public</td>
                        <td>return</td>
                        <td>short</td>
                        <td>static</td>
                    </tr>
                    <tr>
                        <td>stricttfp</td>
                        <td>super</td>
                        <td>switch</td>
                        <td>synchronized</td>
                        <td>this</td>
                    </tr>
                    <tr>
                        <td>throw</td>
                        <td>throws</td>
                        <td>transient</td>
                        <td>true</td>
                        <td>try</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>void</td>
                        <td>volatile</td>
                        <td>while</td>
                        <td></td>
                    </tr>
                </table>
            </code></center>

            <strong><h2 id="T13">13. Destrucción de objetos</h2></strong>

            <p align="justify">Los objetos son puestos en un lugar de memoria llamado Memory Heap. Java tiene un hilo de baja prioridad denominado Garbage Collector que elimina objetos que ya no son referenciados. Se puede invocar manualmente usando <code>System.gc()</code> aunque nada garantiza que se libere la memoria en un momento dado del tiempo, llamar a este método es meramente una sugerencia para Java. Similar a como los constructores crean objetos los destructores se encargan de eliminarlos, el siguiente método se invoca cuando un objeto es elegido por el recolector y puede personalizar la liberación de recursos. En realidad no es muy usado, pero debe mantener en mente que este método nunca se llama dos veces: <code>protected void finalize();</code></p>
        </article>
        <footer id="footer"></footer>
    </body>
    <script type="text/javascript" src="https://platform.linkedin.com/badges/js/profile.js" async defer></script>
    <script type="text/javascript" src="../../../resources/script/libs/jquery/jquery-3.2.1.min.js"></script>
    <script type="text/javascript" src="../../../resources/script/libs/google-code-prettify/prettify.js"></script>
    <script type="text/javascript" src="../../../resources/script/home/template.js" relative="../../../" currentElement="#a_java_basics1"></script>
    <script type="text/javascript">
        PR.prettyPrint();
    </script>
</html>
